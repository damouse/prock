#pragma once

#include "ProckFPS.h"
#include "PythonBindings.h"

#include <vector>

enum ProckNodeType : int;

/**
 * A C++ wrapper around a python AST node. Values are always resolved dynamically through 
 * getters. 
 */
class PROCKFPS_API PythonNode
{
public:
	PythonNode();
	PythonNode(PyObject *native);
	~PythonNode();

	// Initialize the root of the tree since RedBaron returns the first result inconsistently
	void InitRoot(PyObject *astList);

	char *GetAsString(char *name);
	std::vector<PythonNode> GetAsList(char *name);
	PythonNode *GetAsNode(char *name);

	// Dynamic getters for node information
	ProckNodeType Type();
	PythonNode *Target();
	PythonNode *Value();
	PythonNode *First();
	PythonNode *Second();
	std::vector<PythonNode *> RootList();

	// Print this object in prock's representation and in raw python form, respectively
	void Print();
	void PrintRaw();

	PyObject *pythonNode;

private:
	PythonNode *parent;
	
	std::vector<PythonNode *> list; // list of nodes, used by Root

	// Special marker for root. Affects the return type of GetType
	bool isRoot;
};

// Convert a ProckNodeType to string
char *pntToString(ProckNodeType type);

// Create an appropriate python node type from a python string
ProckNodeType pntFromPyString(char *t);

// The abstract "type" of this node. May not be the same as the native AST node reports
// These enums, along with the body of the two methods above, were automatically generated by Source/pypeter/type_printer.py
// by scraping the redbaron classes.
enum ProckNodeType {
	// Meta node types
	PNT_Root,
	PNT_Unknown,
	PNT_Unresolved,

	// Actualy redbaron node types
	PNT_ArgumentGeneratorComprehension,
	PNT_Assert,
	PNT_Assignment,
	PNT_AssociativeParenthesis,
	PNT_Atomtrailers,
	PNT_Binary,
	PNT_BinaryOperator,
	PNT_BinaryRawString,
	PNT_BinaryString,
	PNT_BooleanOperator,
	PNT_Break,
	PNT_CallArgument,
	PNT_Call,
	PNT_Class,
	PNT_CodeBlock,
	PNT_Comma,
	PNT_Comment,
	PNT_Comparison,
	PNT_ComparisonOperator,
	PNT_Complex,
	PNT_ComprehensionIf,
	PNT_ComprehensionLoop,
	PNT_Continue,
	PNT_Decorator,
	PNT_DefArgument,
	PNT_Def,
	PNT_Del,
	PNT_DictArgument,
	PNT_DictComprehension,
	PNT_Dict,
	PNT_Dictitem,
	PNT_Dot,
	PNT_DottedAsName,
	PNT_DottedName,
	PNT_Elif,
	PNT_Ellipsis,
	PNT_ElseAttribute,
	PNT_Else,
	PNT_Endl,
	PNT_Except,
	PNT_Exec,
	PNT_Finally,
	PNT_FloatExponantComplex,
	PNT_FloatExponant,
	PNT_Float,
	PNT_For,
	PNT_FromImport,
	PNT_GeneratorComprehension,
	PNT_Getitem,
	PNT_Global,
	PNT_Hexa,
	PNT_IfElseBlockSibling,
	PNT_If,
	PNT_Ifelseblock,
	PNT_Import,
	PNT_Int,
	PNT_Lambda,
	PNT_LeftParenthesis,
	PNT_ListArgument,
	PNT_ListComprehension,
	PNT_List,
	PNT_Long,
	PNT_NameAsName,
	PNT_Name,
	PNT_Octa,
	PNT_Pass,
	PNT_Print,
	PNT_Raise,
	PNT_RawString,
	PNT_Repr,
	PNT_Return,
	PNT_RightParenthesis,
	PNT_Semicolon,
	PNT_SetComprehension,
	PNT_Set,
	PNT_Slice,
	PNT_Space,
	PNT_Star,
	PNT_StringChain,
	PNT_String,
	PNT_TernaryOperator,
	PNT_Try,
	PNT_Tuple,
	PNT_UnicodeRawString,
	PNT_UnicodeString,
	PNT_UnitaryOperator,
	PNT_While,
	PNT_WithContextItem,
	PNT_With,
	PNT_YieldAtom,
	PNT_Yield,
};